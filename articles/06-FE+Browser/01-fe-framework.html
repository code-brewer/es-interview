<!doctype html><html class="" data-reactroot=""><head><link rel="icon" type="image/png" href="/favicon.png"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="收集汇总梳理全网资源，涵盖 JS/TS 前后端的全方位面试题库（含提示性解析），助力找个好工作！"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/>
<title data-react-helmet="true">前端 · ECMAScript+ 面试宝典</title>
<link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/assets/prism.css"/><link data-react-helmet="true" rel="stylesheet" href="/assets/index.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/assets/prism_tomorrow.css";
    }
  </script>
</head><body><header><h1 class="hide_on_mobile"><a href="/">ECMAScript+ 面试宝典</a></h1><nav><ul><li class="show_on_mobile flex_center"><a class="czs-menu-l" href="#" style="background-image:url(&quot;/assets/czs-menu-l.svg&quot;)"></a></li><li class="show_on_mobile"><h1 class="mobile_title"><a href="/">ECMAScript+ 面试宝典</a></h1></li><li class="hide_on_mobile"><a href="/articles/">文章</a></li><li class="hide_on_mobile"><a href="http://qiniu.ningo.cloud/hylerrix/reward-alipay.png" target="_blank">打赏一下!!</a></li><li class="hide_on_mobile"><a href="https://github.com/hylerrix/deno-tutorial" target="_blank">Deno 钻研之术</a></li><li class="hide_on_mobile"><a href="https://github.com/hylerrix" target="_blank">持续添加中...</a></li><li class="hide_on_mobile"><a href="https://github.com/ningowood" target="_blank">凝果屋</a></li><li class="hide_on_mobile"><a href="https://github.com/hylerrix" target="_blank">关于</a></li><li style="flex-grow:1"></li><li class="flex_center"><a class="czs-github-logo" href="https://github.com/hylerrix/es-interview" target="_blank" style="background-image:url(&quot;/assets/czs-github-logo.svg&quot;)"></a></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/assets/czs-moon-l.svg&quot;)"></span></li></ul></nav></header><aside class="sidebar"><ol><li class=""><a href="/articles/index.html" class="nav_link">ESMAScript+ 面试宝典</a></li><li class=""><a href="/articles/es-timeline.html" class="nav_link">前端大事记</a></li><li class=""><a href="/articles/00-Profession/index.html" class="nav_link">职业 &amp; 成长</a></li><li class="unfold"><a href="/articles/01-Programming/index.html" class="nav_link">编程基础<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/01-Programming/00-language.html" class="nav_link">编程语言</a></li><li class=""><a href="/articles/01-Programming/01-operating-system.html" class="nav_link">操作系统</a></li><li class=""><a href="/articles/01-Programming/02-algorithms.html" class="nav_link">算法</a></li><li class=""><a href="/articles/01-Programming/03-design-patterns.html" class="nav_link">设计模式</a></li><li class=""><a href="/articles/01-Programming/04-software-engineering.html" class="nav_link">工程化</a></li><li class=""><a href="/articles/01-Programming/05-network-security.html" class="nav_link">安全</a></li><li class=""><a href="/articles/01-Programming/06-software-test.html" class="nav_link">测试</a></li><li class=""><a href="/articles/01-Programming/07-version-control.html" class="nav_link">版本控制</a></li></ol></li><li class="unfold"><a href="/articles/02-ECMAScript+/index.html" class="nav_link">ECMAScript+<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/02-ECMAScript+/00-ecmascript.html" class="nav_link">ECMAScript</a></li><li class=""><a href="/articles/02-ECMAScript+/01-javascript.html" class="nav_link">JavaScript 基础知识</a></li><li class=""><a href="/articles/02-ECMAScript+/02-typescript.html" class="nav_link">TypeScript</a></li><li class=""><a href="/articles/02-ECMAScript+/03-javascript-parctice.html" class="nav_link">JavaScript 常见实战题</a></li></ol></li><li class="unfold"><a href="/articles/03-HTML+CSS/index.html" class="nav_link">HTML + CSS<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/03-HTML+CSS/00-html.html" class="nav_link">HTML</a></li><li class=""><a href="/articles/03-HTML+CSS/01-css-design.html" class="nav_link">CSS</a></li><li class=""><a href="/articles/03-HTML+CSS/02-html-css-practice.html" class="nav_link">HTML + CSS 实战</a></li></ol></li><li class="unfold"><a href="/articles/04-Network+API/index.html" class="nav_link">网络 + 前后端协作<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/04-Network+API/00-network.html" class="nav_link">网络</a></li><li class=""><a href="/articles/04-Network+API/01-fe-be-api.html" class="nav_link">前后端协作</a></li><li class=""><a href="/articles/04-Network+API/02-login.html" class="nav_link">登录</a></li></ol></li><li class="unfold"><a href="/articles/05-V8+Runtime/index.html" class="nav_link">V8 + JavaScript 运行时<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/05-V8+Runtime/00-v8.html" class="nav_link">V8</a></li><li class=""><a href="/articles/05-V8+Runtime/01-node.html" class="nav_link">Node</a></li><li class=""><a href="/articles/05-V8+Runtime/02-deno.html" class="nav_link">Deno</a></li></ol></li><li class="unfold"><a href="/articles/06-FE+Browser/index.html" class="nav_link">前端应用开发 + 浏览器<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/06-FE+Browser/00-browser.html" class="nav_link">浏览器</a></li><li class=""><a href="/articles/06-FE+Browser/01-fe-framework.html" class="nav_link active">前端</a></li><li class=""><a href="/articles/06-FE+Browser/02-fe-tooltain.html" class="nav_link">前端工具链</a></li><li class=""><a href="/articles/06-FE+Browser/03-pack-tool.html" class="nav_link">前端打包工具</a></li><li class=""><a href="/articles/06-FE+Browser/04-fe-mobile.html" class="nav_link">移动端 Web 开发</a></li></ol></li><li class="unfold"><a href="/articles/07-BE+Server/index.html" class="nav_link">后端应用开发 + 服务器<span class="czs-angle-up-l" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></span><span class="czs-angle-down-l" style="background-image:url(&quot;/assets/czs-angle-down-l.svg&quot;)"></span></a><ol><li class=""><a href="/articles/07-BE+Server/00-linux-nginx-database.html" class="nav_link">Linux + Nginx + 数据库</a></li><li class=""><a href="/articles/07-BE+Server/01-node-framework.html" class="nav_link">Node 框架</a></li></ol></li></ol></aside><section class="main"><div class="main_article"><article><h1>前端</h1>
<h2 id="%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84">前端架构<a class="anchor" href="#%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84">§</a></h2>
<ul>
<li>权限组件的设计</li>
<li>SSR</li>
<li>SPA</li>
<li>双向绑定</li>
<li>懒加载</li>
<li>MVVM：Proxy 与 object.defineProperty</li>
</ul>
<h2 id="react">React<a class="anchor" href="#react">§</a></h2>
<ul>
<li>React v15, v16, v17</li>
<li>生命周期（v15 到 v16）、组件化</li>
<li>React -&gt; Hooks、useEffect、setState</li>
<li>懒加载</li>
<li>Redux</li>
<li>Fiber</li>
<li>Concurrent</li>
<li>性能优化：function component + redux、immutable、pure component , shouldComponentUpdate ...</li>
</ul>
<h2 id="setstate%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86">setState背后的原理<a class="anchor" href="#setstate%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86">§</a></h2>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF-fiber">什么是 Fiber<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF-fiber">§</a></h2>
<h2 id="%E6%80%8E%E4%B9%88%E7%94%A8-transaction-%E5%81%9A%E6%89%B9%E6%9B%B4%E6%96%B0">怎么用 transaction 做批更新<a class="anchor" href="#%E6%80%8E%E4%B9%88%E7%94%A8-transaction-%E5%81%9A%E6%89%B9%E6%9B%B4%E6%96%B0">§</a></h2>
<h2 id="%E8%99%9A%E6%8B%9F-dom-%E5%8E%9F%E7%90%86">虚拟 DOM 原理<a class="anchor" href="#%E8%99%9A%E6%8B%9F-dom-%E5%8E%9F%E7%90%86">§</a></h2>
<h2 id="vue">Vue<a class="anchor" href="#vue">§</a></h2>
<blockquote>
<p>nexttick</p>
</blockquote>
<blockquote>
<p>React 和 Vue 的区别</p>
</blockquote>
<p>相同点</p>
<ul>
<li>都有组件化开发和Virtual DOM</li>
<li>都支持props进行父子组件间数据通信</li>
<li>都支持数据驱动视图, 不直接操作真实DOM, 更新状态数据界面就自动更新</li>
<li>都支持服务器端渲染</li>
<li>都有支持native的方案,React的React Native,Vue的Weex</li>
</ul>
<p>不同点</p>
<ul>
<li>数据绑定: vue实现了数据的双向绑定,react数据流动是单向的</li>
<li>组件写法不一样, React推荐的做法是 JSX , 也就是把HTML和CSS全都写进JavaScript了,即'all in js'; Vue推荐的做法是webpack+vue-loader的单文件组件格式,即html,css,js写在同一个文件</li>
<li>state对象在react应用中不可变的,需要使用setState方法更新状态;在vue中,state对象不是必须的,数据由data属性在vue对象中管理</li>
<li>virtual DOM不一样,vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树.而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li>
<li>React严格上只针对MVC的view层,Vue则是MVVM模式</li>
</ul>
<p>概念</p>
<ul>
<li>
<p>组件通信：父向子、子向父、隔代、兄弟</p>
</li>
<li>
<p>实现通信方式</p>
</li>
<li>
<ul>
<li>props：父向子传递一般属性、子向父传递函数属性；缺点隔代不好</li>
<li>vue 自定义事件：Vue 内置，代替函数类型的 props【绑定监听 @、触发事件 emit】</li>
<li>消息订阅与发布：常见订阅库 pubsub-js，适用于任意关系组件</li>
<li>vuex：相比 pubsub 管理起来更集中方便</li>
<li>slot：专门用来实现父向子传递带数据的标签</li>
</ul>
</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-gettersetter-%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">如何解决 getter/setter 不能监听数组变异方法<a class="anchor" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-gettersetter-%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">§</a></h2>
<h2 id="%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E8%80%A6%E7%9A%84">监听的回调和事件怎么解耦的<a class="anchor" href="#%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E8%80%A6%E7%9A%84">§</a></h2>
<h2 id="watcher-%E5%8E%BB%E9%87%8D%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">watcher 去重怎么做的<a class="anchor" href="#watcher-%E5%8E%BB%E9%87%8D%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">§</a></h2>
<h2 id="dom%E6%89%B9%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">DOM批更新怎么做的<a class="anchor" href="#dom%E6%89%B9%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">§</a></h2>
<h2 id="%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">前端性能优化<a class="anchor" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">§</a></h2>
<ul>
<li>图片懒加载？</li>
<li>给页面注入50万个li怎么做提升性能？</li>
<li>Base64</li>
</ul>
<blockquote>
<p>网页很卡的原因</p>
</blockquote>
<ul>
<li>带宽不足、硬件配置低、CPU 或者是内存被占满。</li>
<li>HTTP 请求次数太多。</li>
<li>接收数据时间过长，如下载资源过大。</li>
<li>JS 脚本过大，阻塞了页面的加载。</li>
<li>网页资源过多、接受数据时间长、加载某个资源慢。</li>
<li>DNS 解析速度。</li>
</ul>
<blockquote>
<p>性能优化的方法</p>
</blockquote>
<ul>
<li>资源压缩、文件合并</li>
<li>非核心代码异步加载（script 标签的 defer 和 async 属性）</li>
<li>浏览器缓存：强缓存、协商缓存</li>
<li>CDN</li>
<li>资源预加载：预解析DNS</li>
</ul>
<h2 id="%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2">前端部署<a class="anchor" href="#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2">§</a></h2>
<ul>
<li>如何保证打包文件替换过程中，用户体验不断</li>
<li>前端的多集群分布式部署？</li>
</ul>
<h2 id="%E5%89%8D%E7%AB%AF--%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%80%A7">前端 + 浏览器安全性<a class="anchor" href="#%E5%89%8D%E7%AB%AF--%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%80%A7">§</a></h2>
<ul>
<li>Xss csrf</li>
</ul>
<h2 id="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91">移动端开发<a class="anchor" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91">§</a></h2>
<ul>
<li>React Native、Flutter</li>
</ul>
<h2 id="spa-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">SPA 单页面应用有什么特点？<a class="anchor" href="#spa-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">§</a></h2>
<p>“网络应用”相较于“网站”，具有高度的交互性和动态性，允许用户执行操作并接收他们的操作响应。</p>
<ul>
<li>在过去，浏览器从服务器接收 HTML 并渲染。当用户导航到其它 URL 时，需要整页刷新，服务器会为新页面发送新的 HTML，这被称为服务器端渲染。</li>
<li>在现代的 SPA 中，客户端渲染取而代之，浏览器从服务器加载初始页面，以及整个应用程序所需的脚本(框架、库、应用代码)和样式表。当用户导航到其他页面时，不会触发页面刷新。该页面的 URL 通过 HTML5 History API 进行更新。浏览器通过 AJAX 请求向服务器检索新页面所需的数据(通常 JSON 格式)</li>
<li>SPA 带来了：
<ul>
<li>应用的表现层从服务器端脱离出来，在浏览器管理</li>
<li>提升应用设计、代码维护和开发时间等方面的效率</li>
<li>服务端的事务处理仅限于数据</li>
<li>解决整页刷新、请求重复、重负荷事物处理等问题</li>
<li>嵌入脚本</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>好处：</p>
<ul>
<li>用户感知响应快，用户切换页面时，不再看到因页面刷新而导致的白屏。</li>
<li>对服务器进行的 HTTP 请求减少，因为对于每个页面加载，不必再次下载相同的资源。</li>
<li>客户端和服务器之间的关注点分离。可以为不同平台(手机、聊天机器人、智能手表)建立新的客户端，而无需修改服务器代码。只要 API 没有修改，可以单独修改客户端和服务器上的代码。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>由于加载了多个页面所需的框架、应用和资源，导致初始页面加载时间较长。</li>
<li>服务器还需要进行额外的工作，需要将所有请求路由配置到单个入口点，然后由客户端接管路由。</li>
<li>SPA 依赖于 JavaScript 来呈现内容，但并非所有搜索引擎都在抓取过程中执行 JavaScript，他们可能会在你的页面上看到空的内容。这无意中损害了应用的搜索引擎优化(SEO)。然而，当你构建应用时，大多情况下，搜索引擎优化并不是最重要的因素，因为并非所有内容都需要通过搜索引擎进行索引。为了解决这个问题，可以在服务器端渲染你的应用，或者使用诸如 Prerender 的服务来“在浏览器中呈现你的 JavaScript，保存静态 HTML，将其返回给爬虫”</li>
</ul>
</li>
<li>
<p>SPA 技术要点：</p>
<ul>
<li>组织项目(文件结构)</li>
<li>创建可维护的松耦合 UI</li>
<li>使用 JavaScript 模块</li>
<li>执行 SPA 导航：SPA 布局 = Shell 页面 + Region 容器</li>
<li>创建视图组成与布局</li>
<li>模块通信：pub/sub 设计模式</li>
<li>与服务器通信</li>
<li>执行单元测试</li>
<li>客户端自动化技术</li>
</ul>
</li>
<li>
<p>SPA 模型</p>
<ul>
<li>隐式模型：v-model、v-bind</li>
<li>显式模型：Backbone.js</li>
</ul>
<ul>
<li>模型的绑定
<ul>
<li>用来自由混入模板的 HTML 代码</li>
<li>绑定类型
<ul>
<li>属性：ng-bind、v-bind</li>
<li>表达式：{{ aaa }}、&lt;%= aaa %&gt;</li>
</ul>
</li>
<li>定向绑定
<ul>
<li>单向绑定：ng-bind、v-bind</li>
<li>单次绑定：渲染期间只发生一次</li>
<li>双向绑定，与 UI 控件关联，采用观察者模式，需要付出开销代价：ng-model、v-model</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SPA 模板</p>
<ul>
<li>模板引擎：在 MV* 中将模板和模型数据结合起来</li>
<li>模板：HTML 片段——可额外包含多种绑定及其他指令</li>
<li>模板渲染</li>
<li>模板存放位置
<ul>
<li>内嵌模板：SPA 初始下载，type=&quot;text/template&quot;</li>
<li>局部模板：按需下载</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>SPA 模块：模块模式、模块化编程等</li>
</ul>
<h2 id="spa-%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86">SPA 路由的原理？<a class="anchor" href="#spa-%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86">§</a></h2>
<ul>
<li>客户端路由器
<ul>
<li>侦测浏览器位置发生的变化，监听特定事件</li>
<li>管理 SPA 视图、数据以及业务事物状态</li>
<li>浏览器导航控制</li>
</ul>
</li>
<li>路由术语
<ul>
<li>名称：路由标识</li>
<li>动词：get、put、on、when</li>
<li>路径：URL 部分，建立路由/路由处理程序之间的链接</li>
<li>功能：可能执行的相关代码(控制器、回调函数)</li>
</ul>
</li>
<li>路由配置
<ul>
<li>路由语法</li>
<li>路由配置项：当路由找到匹配 URL 时，该如何动作</li>
<li>路由参数：在路由路径中定义的变量</li>
<li>缺省路由</li>
</ul>
</li>
<li>客户端路由器的工作机制
<ul>
<li>片段标识符方式，# 为前缀，使用 location 的 onhashchange 时间</li>
<li>HTML 历史 API 方式，兼容性差，使用片段标识符作为回退方案
<ul>
<li>pushState、replaceState、pospstate</li>
<li>三个参数：状态对象、标题、URL</li>
<li>基准链接：服务器端调整(重定向)、移除 hash</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="mv-%E6%A1%86%E6%9E%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9">MV* 框架都有哪些及其特点？<a class="anchor" href="#mv-%E6%A1%86%E6%9E%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9">§</a></h2>
<ul>
<li>
<p>MV* 框架</p>
<ul>
<li>MVC：模型、视图、控制器</li>
<li>MVP：模型、视图、表示器</li>
<li>MVVM：模型、视图、视图模型</li>
</ul>
</li>
<li>
<p>为什么要使用 MV* 框架：关注点分离、简化日常任务、提升生产率、标准化、更高效的合作、独立代码更容易更改、更干净的单元测试。</p>
</li>
</ul>
<h2 id="%E8%99%9A%E6%8B%9F-dom-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">虚拟 DOM 的原理是什么？<a class="anchor" href="#%E8%99%9A%E6%8B%9F-dom-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">§</a></h2>
<p>近年来，前端的框架主要发展方向就是解放DOM操作的复杂性。虚拟的 DOM 的核心思想是：对复杂的文档 DOM 结构，提供一种方便的工具，进行最小化地 DOM 操作。</p>
<ul>
<li>算法实现
<ol>
<li>用 JS 对象模拟 DOM 树</li>
<li>比较两棵虚拟 DOM 树的差异</li>
<li>把差异应用到真正的 DOM 树上</li>
</ol>
</li>
<li>DOM patching，DOM 修补</li>
<li>DOM diff</li>
</ul>
<h2 id="%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">前端性能优化需要注意什么？<a class="anchor" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">§</a></h2>
<ul>
<li>最大限度地减少 HTTP 请求：</li>
<li>使用内容分发网络</li>
<li>headers 添加一个 Expires 或Cache-Control 头</li>
<li>用 gzip 的压缩内容</li>
<li>将样式表在顶部</li>
<li>JS 代码放在底部</li>
<li>避免使用 CSS 表达式</li>
<li>JavaScript 和 CSS 放在外部</li>
<li>减少 DNS 查找</li>
<li>缩小 JavaScript 和 CSS</li>
<li>避免重定向</li>
<li>删除重复的脚本和样式</li>
<li>减少 DOM 元素的数量</li>
<li>CSS 雪碧图</li>
<li>HTTP 缓存</li>
<li>尽量避免回流</li>
<li>复合层、简单层与硬件加速</li>
<li>工程化打包</li>
<li>复合层与性能优化</li>
</ul>
<p>静态资源域名拆分（HTTP 2.0 不需要）</p>
<ul>
<li>将静态资源分组，分别放到不同的域名下(<a href="http://xn--static-hh4k.base.com">如static.base.com</a>)</li>
<li>而 <a href="http://page.base.com">page.base.com</a>(页面所在域名)下请求时，是不会带上 <a href="http://static.base.com">static.base.com</a> 域名的 cookie 的，所以就避免了浪费</li>
<li>在移动端，如果请求的域名数过多，会降低请求速度(因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc)，此时就需要用到一种优化方案：dns-prefetch(让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用)</li>
</ul>
<h2 id="%E5%89%8D%E7%AB%AF%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%8E%8B%E7%BC%A9">前端都可以怎么压缩？<a class="anchor" href="#%E5%89%8D%E7%AB%AF%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%8E%8B%E7%BC%A9">§</a></h2>
<p>GZip 压缩</p>
<ul>
<li>是一种压缩格式，需要浏览器支持才有效(不过一般现在浏览器都支持)， 而且 GZip 压缩效率很好(高达70%左右)</li>
<li>然后 GZip 一般是由 Apache、Tomcat 等 Web 服务器开启</li>
<li>服务器除了 GZip 外，也还会有其它压缩格式(如 deflate，没有 gzip 高效，且不流行)</li>
<li>一般只需要在服务器上开启了 GZip 压缩，然后之后的请求就都是基于 GZip 压缩格式的, 非常方便。</li>
</ul></article><div class="prev_next"><a class="prev button" href="/articles/06-FE+Browser/00-browser.html">«  <!-- -->浏览器</a><a class="next button" href="/articles/06-FE+Browser/02-fe-tooltain.html">前端工具链<!-- -->  »</a></div></div><div class="main_toc_container nav_link_container"><div class="main_toc"><aside><nav class="toc"><ol><li><a href="#%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84">前端架构</a></li><li><a href="#react">React</a></li><li><a href="#setstate%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86">setState背后的原理</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-fiber">什么是 Fiber</a></li><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8-transaction-%E5%81%9A%E6%89%B9%E6%9B%B4%E6%96%B0">怎么用 transaction 做批更新</a></li><li><a href="#%E8%99%9A%E6%8B%9F-dom-%E5%8E%9F%E7%90%86">虚拟 DOM 原理</a></li><li><a href="#vue">Vue</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-gettersetter-%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95">如何解决 getter/setter 不能监听数组变异方法</a></li><li><a href="#%E7%9B%91%E5%90%AC%E7%9A%84%E5%9B%9E%E8%B0%83%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%80%8E%E4%B9%88%E8%A7%A3%E8%80%A6%E7%9A%84">监听的回调和事件怎么解耦的</a></li><li><a href="#watcher-%E5%8E%BB%E9%87%8D%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">watcher 去重怎么做的</a></li><li><a href="#dom%E6%89%B9%E6%9B%B4%E6%96%B0%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">DOM批更新怎么做的</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">前端性能优化</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2">前端部署</a></li><li><a href="#%E5%89%8D%E7%AB%AF--%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%80%A7">前端 + 浏览器安全性</a></li><li><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91">移动端开发</a></li><li><a href="#spa-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">SPA 单页面应用有什么特点？</a></li><li><a href="#spa-%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86">SPA 路由的原理？</a></li><li><a href="#mv-%E6%A1%86%E6%9E%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9">MV* 框架都有哪些及其特点？</a></li><li><a href="#%E8%99%9A%E6%8B%9F-dom-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">虚拟 DOM 的原理是什么？</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">前端性能优化需要注意什么？</a></li><li><a href="#%E5%89%8D%E7%AB%AF%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%8E%8B%E7%BC%A9">前端都可以怎么压缩？</a></li></ol></nav></aside></div></div></section><footer>Powered by<!-- --> <a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><div class="tools flex_center hide_on_mobile"><a class="czs-pen button" href="https://github.com/hylerrix/es-interview/edit/master/articles/06-FE+Browser/01-fe-framework.md" target="_blank" style="background-image:url(&quot;/assets/czs-pen.svg&quot;)"></a><a class="czs-angle-up-l button" href="#" style="background-image:url(&quot;/assets/czs-angle-up-l.svg&quot;)"></a></div><script crossorigin="anonymous" src="https://unpkg.com/react@16.13.1/umd/react.production.min.js"></script><script crossorigin="anonymous" src="https://unpkg.com/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/index.js"></script></body></html>