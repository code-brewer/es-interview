# 网络

- 输入网站发生了什么？
  - TCP/IP 模型？HTTP 请求/响应体，响应码
- HTTP 缓存
  - 强缓存、协商缓存
- 同源策略/跨域
- HTTP1.0、HTTP1.1 和 HTTP2.0
- HTTP 方法，302、304
- HTTPS
- CDN
- 三次握手、四次挥手

> TCP 和 UDP

- TCP

- - 面向连接
  - 每条连接一对一
  - 提供可靠的交付服务
  - 全双工通信
  - 面向字节流

- UDP

- - 无连接
  - 不保证可靠交付
  - 面向报文
  - 无拥塞控制
  - 支持一对一、一对多、多对一和多对多的交互通信
  - 首部开销小：只有四个字段，源端口、目的端口、长度、校验和

> GET 和 POST 区别

GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被Bookmark，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST么有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

GET参数通过URL传递，POST放在Request body中。

> HTTPS

- HTTPS = HTTP + SSL(安全套接字, 传输层)

- - 443 端口
  - 加密：公钥（非对称加密算法）和秘钥（对称加密算法）
  - HASH 算法用来确认信息没有被篡改，来生成签名
  - 数字证书：包含证书发布机构、有效期、公钥、证书所有者、签名使用的算法
  - 数字签名：只存在于验证阶段
  - 证书链：证书是分级的，拿到上级证书的公钥才能解密本级证书
  - 验证流程

- - - 客户端发 HTTP 请求，连接到服务器的 443 端口
    - 服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。
    - 验证证书的合法性：客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。
    - 生成随机密码（RSA签名）：如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。
    - 互相用这个对称加密算法来加密和解密通信内容

* GET/POST/PUT/DELETE/OPTIONS 有什么区别？



## URL 和 URI 是什么？

* URL 一般包括几大部分：
  * protocol，协议头，譬如有 http、ftp 等
  * host，主机域名或 IP 地址
  * port，端口号
  * path，目录路径
  * query，查询参数
  * fragment，即 # 后的 hash 值，一般用来定位到某个位置
* 公式
  * URL = 协议 + Web 服务器名(域名或 IP) + 目录名 + 文件名(可选)
  * URL = 协议 + Web 服务器名(域名或 IP) + CGI 程序接口名
* URL 根据访问目标不同，可以包括：服务器域名；访问的文件路径；收件地址；用户名、密码、服务器端口号；新闻组名。

## HTTP/1 ~ HTTP/3 的新特性？

* HTTP 2.0：不是 HTTPS，它相当于是 HTTP 的下一代规范。使用 HTTP 2.0 时，不需要雪碧图、域名拆分等优化技术。
  * 多路复用(即一个 TCP/IP 连接可以请求多个资源)
  * 首部压缩(HTTP 头部压缩，减少体积)
  * 二进制分帧(在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量)
  * 服务器端推送(服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端)
  * 请求优先级(如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。)
* HTTP 2.0 和 HTTP 1.1 区别
  * HTTP 1.1中，每请求一个资源，都是需要开启一个 TCP/IP 连接的，所以对应的结果是，每一个资源对应一个 TCP/IP 请求，由于 TCP/IP 本身有并发数限制，所以当资源一多，速度就显著慢下来。
  * HTTP 2.0中，一个 TCP/IP 请求可以请求多个资源，也就是说，只要一次 TCP/IP 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。

## HTTPS 是什么？

* HTTPS 就是安全版本的 HTTP，HTTP 请求的安全系数太低。
* HTTPS 在请求前，会建立 SSL 链接，确保接下来的通信都是加密的，无法被轻易截取分析
* 升级为 HTTPS
  * 一般来说，如果要将网站升级成 HTTPS ，需要后端支持(后端需要申请证书等)，然后 HTTPS 的开销也比 HTTP 要大（因为需要额外建立安全链接以及加密等），所以一般来说 HTTP 2.0 配合 HTTPS 的体验更佳(因为 HTTP2.0 更快)
* SSL/TLS的握手流程
  * 浏览器请求建立 SSL 链接，并向服务端发送一个随机数，Client random 和客户端支持的加密方法，比如 RSA 加密，此时是明文传输。
  * 服务端从中选出一组加密算法与 Hash 算法，回复一个随机数，Server random，并将自己的身份信息以证书的形式发回给浏览器(证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息)
  * 浏览器收到服务端的证书后
    * 验证证书的合法性(颁发机构是否合法，证书中包含的网址是否和正在访问的一样)，如果证书信任，则浏览器会显示一个小锁头，否则会有提示。
    * 用户接收证书后(不管信不信任)，浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密 Premaster secret，发送给服务器。
    * 利用 Client random、Server random和 Premaster secret 通过一定的算法生成 HTTP 链接数据传输的对称加密 key- session key
    * 使用约定好的 HASH 算法计算握手消息，并使用生成的 session key 对消息进行加密，最后将之前生成的所有信息发送给服务端。
  * 服务端收到浏览器的回复
    * 利用已知的加解密方式与自己的私钥进行解密，获取 Premaster secret
    * 和浏览器相同规则生成 session key
    * 使用 session key 解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致
    * 使用 session key 加密一段握手消息，发送给浏览器
  * 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。

## HTTP 的主要方法？

PUT 和 DELETE 常用于 RESTful API 设计中，App 和后端交互时常用

* GET，获取 URI 指定的信息(文件、CGI 程序)。
* POST，发送数据。
* HEAD，只返回 HTTP 消息头。
* OPTIONS，用于通知或查询通信选项。
* PUT，替换 URI 指定的服务器上文件，若不存在则新建。
* DELETE，删除  URI 指定的服务器上文件，若不存在则新建。
* TRACE，将服务器收到的请求行和头部直接返回。
* CONNECT，代理传输加密消息时使用的方法。

## HTTP 报文结构与常见字段？

```markdown
# 请求报文
# 消息头，从 字段名:字段值 开始，一直延伸到空行。
# 消息体可以包含 POST 方法要发送的内容等。
方法<空格>URI<空格>HTTP 版本
字段名:字段值
...
空行
消息体
# 响应报文
# 消息体均为二进制：文件中读取的数据、如 CGI 程序输出的数据
HTTP 版本<空格>状态码<空格>响应短语
字段名:字段值
...
空行
消息体
```

## 常见的 HTTP 状态码都有哪些？

* 1XX 消息，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。
* 2XX 成功，代表请求已成功被服务器接收、理解、并接受。
* 3XX 重定向，代表需要客户端采取进一步的操作才能完成请求。通常用来重定向，后续的请求地址(重定向目标)在本次相应的 Location 域中指明。当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向(例如：A→B→C→……→A 或 A→A)，因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。
* 4XX 客户端错误，代表客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。
* 5XX 服务器错误，代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。

| 状态码 | 状态码英文名称      | 中文描述                                                     |
| ------ | ------------------- | ------------------------------------------------------------ |
| 100    | Continue            | 继续。客户端应继续其请求.                                    |
| 101    | Switching Protocols | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。 |
| 102    | Processing          | 表示服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。 |

| 状态码 | 状态码英文名称                | 中文描述                                                     |
| ------ | ----------------------------- | ------------------------------------------------------------ |
| 200    | OK                            | 请求成功，请求所希望的响应头或数据体将随此响应返回。一般用于 GET 与 POST 请求。 |
| 201    | Created                       | 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其 URI 已经随 Location  头信息返回。假如需要的资源无法及时创建的话，应当返回 '202 Accepted'。 |
| 202    | Accepted                      | 服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。 |
| 203    | Non-Authoritative Information | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而返回转换代理服务器上的一个副本 |
| 204    | No Content                    | 服务器成功处理了请求，没有返回任何内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                 | 服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。可通过此返回码清除浏览器的表单域。 |
| 206    | Partial Content               | 服务器已经成功处理了部分 GET 请求。HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 |
| 207    | Multi-Status                  | 代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 |
| 208    | Already Reported              | DAV 绑定的成员已经在(多状态)响应之前的部分被列举，且未被再次包含。 |
| 226    | IM Used                       | 服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。 |

| 状态码 | 状态码英文名称     | 中文描述                                                     |
| ------ | ------------------ | ------------------------------------------------------------ |
| 300    | Multiple Choices   | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端(例如：浏览器)选择 |
| 301    | Moved Permanently  | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
| 302    | Found              | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI |
| 303    | See Other          | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看         |
| 304    | Not Modified       | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy          | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused             | 已经被废弃的 HTTP 状态码                                     |
| 307    | Temporary Redirect | 临时重定向。与 302 类似。使用 GET 请求重定向                 |
| 308    | Permanent Redirect | 状态码                                                       |

| 400  | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| ---- | ------------------------------- | ------------------------------------------------------------ |
| 401  | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402  | Payment Required                | 保留，将来使用                                               |
| 403  | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | Not Found                       | 服务器无法根据客户端的请求找到资源(网页)。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405  | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406  | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407  | Proxy Authentication Required   | 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权 |
| 408  | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409  | Conflict                        | 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410  | Gone                            | 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置 |
| 411  | Length Required                 | 服务器无法处理客户端发送的不带 Content-Length 的请求信息     |
| 412  | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413  | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息 |
| 414  | Request-URI Too Large           | 请求的 URI 过长(URI通常为网址)，服务器无法处理               |
| 415  | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416  | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417  | Expectation Failed              | 服务器无法满足 Expect 的请求头信息                           |

| 500  | Internal Server Error      | 服务器内部错误，无法完成请求                                 |
| ---- | -------------------------- | ------------------------------------------------------------ |
| 501  | Not Implemented            | 服务器不支持请求的功能，无法完成请求                         |
| 502  | Bad Gateway                | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |
| 503  | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 |
| 504  | Gateway Time-out           | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505  | HTTP Version not supported | 服务器不支持请求的 HTTP 协议的版本，无法完成处理             |

## HTTP 的缓存机制是怎样的？

* 缓存可以简单的划分成两种类型：强缓存(200 from cache)与协商缓存(304)。
  * 强缓存(200 from cache)时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 HTTP 请求。对于强缓存，在未过期时，必须更新资源路径才能发起新的请求。
  * 协商缓存(304)时，浏览器会向服务端发起 HTTP 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存。对于协商缓存，使用 Ctrl + F5 强制刷新可以使得缓存无效。
* HTTP 缓存头部
  * 强缓存和协商缓存通过缓存头部区分。常用的缓存头部有：If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires。
  * 属于强缓存控制的：
    * (http1.1)Cache-Control/Max-Age，Max-Age 不是一个头部，它是 Cache-Control 头部的值
    * (http1.0)Pragma/Expires
  * 属于协商缓存控制的：
    * (http1.1)If-None-Match/E-tag
    * (http1.0)If-Modified-Since/Last-Modified
* 其实 HTML 页面中也有一个 meta 标签可以控制缓存方案 Pragma，不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐。`<META HTTP-EQUIV="Pragma" CONTENT="no-cache">`

Max-Age 与 Expires

- Expires 使用的是服务器端的时间
- 但是有时候会有这样一种情况-客户端时间和服务端不同步
- 那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期
- 所以一般 HTTP 1.1 后不推荐使用 Expires
- 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题
- 因此推荐使用Max-Age
- 注意，如果同时启用了 Cache-Control 与 Expires，Cache-Control 优先级高

E-tag 与 Last-Modified

* Last-Modified：
  * 表明服务端的文件最后何时改变的
  * 它有一个缺陷就是只能精确到 1s，
  * 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效
* E-tag：
  * 是一种指纹机制，代表文件相关指纹
  * 只有文件变才会变，也只要文件变就会变，
  * 也没有精确时间的限制，只要文件一遍，立马 E-tag 就不一样了

HTTP 各版本缓存控制头部

* HTTP 1.0 中的缓存控制头部：
  - **Pragma**：严格来说，它不属于专门的缓存控制头部，但是它设置 no-cache 时可以让本地强缓存失效(属于编译控制，来实现特定的指令，主要是因为兼容 HTTP1.0，所以以前又被大量应用)
  - **Expires**：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如 Expires：Fri, 30 Oct 1998 14:19:41
  - **If-Modified-Since/Last-Modified**：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-Modified-Since，而服务端的是 Last-Modified，它的作用是，在发起请求时，如果 If-Modified-Since 和 Last-Modified 匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到 1s 以内
* HTTP 1.1 中的缓存控制头部：
  - **Cache-Control**：缓存控制头部，有 no-cache、max-age 等多种取值
  - **Max-Age**：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算
  - **If-None-Match/E-tag**：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-None-Match，而服务端的是 E-tag，同样，发出请求后，如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，它是类似于指纹一样的东西，基于 FileEtag INode Mtime Size 生成，也就是说，只要文件变，指纹就会变，而且没有 1s 精确度的限制。

## TCP/IP 的三次握手与四次挥手？

* 三次握手
  - client：hello，你是 server 么？
  - server：hello，我是 server，你是 client 么？
  - client：yes，我是 client
* 四次挥手
  - 主动方：我已经关闭向你那边的主动通道了，只能被动接受了
  - 被动方：收到通道关闭消息
  - 被动方：那我也告诉你，我这边向你的主动通道也关闭了
  - 主动方：最后收到数据，之后双方无法通信

## TCP/IP 的长连接和短连接什么区别？

> Keep-Alive 不会永远保持，它有一个持续时间，一般在服务器中配置(如 Apache)，另外长连接需要客户端和服务器都支持时才有效

* TCP/IP 层面的定义：
  - 长连接：一个 TCP/IP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持(类似于心跳包)
  - 短连接：通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接
* HTTP 层面的定义：
  - HTTP 1.0 中，默认使用的是短连接，也就是说，浏览器没进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接。
  - HTTP 1.1 起，默认使用长连接，使用长连接会有这一行 `Connection: keep-alive`，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 HTTP 的 TCP 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接。

## IPV4、IPV6 是什么，如何分类？



## DNS 服务器的工作机制是怎样的？

* DNS 查询得到 IP 的过程：
  * 如果浏览器有缓存、直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host
  * 如果本地没有，就向 DNS 域名服务器查询，中间过程经过的路由可能也有缓存，查询得到对应的 IP
* DNS 查询优化
  * 解析域名过多时，会让首屏加载速度变得过慢，可以考虑 dns-prefetch 优化。

```javascript
// gethostbyname 返回 IP 地址
<内存地址> = gethostbyname("要查询的服务器域名");

gethostbyname {
    生成发送给 DNS 服务器的查询信息;
    // 发送查询消息，需要委托给操作系统内部协议栈
    向 DNS 服务器发送查询消息;
    接收 DNS 服务器返回的响应消息;
    从响应消息中取出 IP 地址，存放到 <内存地址中>;
    返回应用程序;
}
```

* DNS 预解析：“Google Chrome 浏览器”等现代浏览器还采用了一种称为“DNS 预解析”的技术，可以更快地抓取和载入网页。通过 DNS 查找将网址转换为 IP 地址的过程称为“解析”，反之则称为“反向解析”。“Chrome 浏览器”会通过 DNS 预解析同时查找网页上的其他所有链接，并在后台将这些链接预解析为 IP 地址。因此，当您实际点击网页上的某个链接后，浏览器就能立即将您转到新的网页。


## 浏览器输入网址到显示页面发生了什么？

* 关键字

  * level1: http、后台、浏览器渲染、js 引擎
  * level2: http 报文通信、render 树构建流程、layout、paint、复合层与简单层、常用优化方案、JS引擎的变量提升、执行上下文、VO、AO、作用域链、回收机制、http 报文结构、缓存机制、http2.0、https、跨域与安全
  * level3: 键盘输入、操作系统交互、屏幕显示原理、网卡等硬件交互、浏览器的多进程和浏览器内核的多县城、网络线程、dns 查询、tcp/ip 链接、五层因特尔协议栈、DNS 优化方案、负载均衡、安全拦截、http 场景头部、cookie、跨域、web 安全、http 缓存、http2..0、https、解析 HTML 词法分析成 DOM 树、解析 CSS 为 CSS 规则树、合并 render 树、layout/painting 渲染、复合层的合成、GPU 绘制、外链处理、加载顺序
  * level4: 架构、整体把握、大型工程构建
* 关键名词：Web 浏览器、TCP/IP、网卡驱动、集线器、路由器、接入网、电话局、网络运营商、电话局、接入网、防火墙、缓存服务器、网卡驱动、TCP/IP、Web 服务器程序
* 一种思路
  * 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
  * 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
  * 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
  * 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
  * 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）
  * 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
  * CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）
  * JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
  * 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
* 当初始的 HTML 文档完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
* window 的 load 事件仅在 DOM 和所有相关资源全部完成加载后才会触发。

