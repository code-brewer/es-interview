# 网络

> DNS 域名解析、ARP 与 RARP 协议、DHCP 动态获取 IP 地址、NAT 网络地址转换、ICMP 互联网控制报文协议、IGMP 因特网组管理协议

## TCP 和 UDP 有什么区别？

- TCP

  ​	面向连接

  - 每条连接一对一
  - 提供可靠的交付服务
  - 全双工通信
  - 面向字节流

- UDP

  - 无连接
  - 不保证可靠交付
  - 面向报文
  - 无拥塞控制
  - 支持一对一、一对多、多对一和多对多的交互通信
  - 首部开销小：只有四个字段，源端口、目的端口、长度、校验和

## GET 和 POST 区别？

* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST么有。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。

## OPTION？

## HTTPS 的机制是什么？

- HTTPS = HTTP + SSL(安全套接字, 传输层)
  - 443 端口
  - 加密：公钥（非对称加密算法）和秘钥（对称加密算法）
  - HASH 算法用来确认信息没有被篡改，来生成签名
  - 数字证书：包含证书发布机构、有效期、公钥、证书所有者、签名使用的算法
  - 数字签名：只存在于验证阶段
  - 证书链：证书是分级的，拿到上级证书的公钥才能解密本级证书
  - 验证流程
- - - 客户端发 HTTP 请求，连接到服务器的 443 端口
    - 服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。
    - 验证证书的合法性：客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。
    - 生成随机密码（RSA签名）：如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。
    - 互相用这个对称加密算法来加密和解密通信内容

* GET/POST/PUT/DELETE/OPTIONS 有什么区别？

## URL 和 URI 是什么？

* URL 一般包括几大部分：
  * protocol，协议头，譬如有 http、ftp 等
  * host，主机域名或 IP 地址
  * port，端口号
  * path，目录路径
  * query，查询参数
  * fragment，即 # 后的 hash 值，一般用来定位到某个位置
* 公式
  * URL = 协议 + Web 服务器名(域名或 IP) + 目录名 + 文件名(可选)
  * URL = 协议 + Web 服务器名(域名或 IP) + CGI 程序接口名
* URL 根据访问目标不同，可以包括：服务器域名；访问的文件路径；收件地址；用户名、密码、服务器端口号；新闻组名。

## HTTP/1 ~ HTTP/3 的新特性？

* HTTP 2.0：不是 HTTPS，它相当于是 HTTP 的下一代规范。使用 HTTP 2.0 时，不需要雪碧图、域名拆分等优化技术。
  * 多路复用(即一个 TCP/IP 连接可以请求多个资源)
  * 首部压缩(HTTP 头部压缩，减少体积)
  * 二进制分帧(在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量)
  * 服务器端推送(服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端)
  * 请求优先级(如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。)
* HTTP 2.0 和 HTTP 1.1 区别
  * HTTP 1.1中，每请求一个资源，都是需要开启一个 TCP/IP 连接的，所以对应的结果是，每一个资源对应一个 TCP/IP 请求，由于 TCP/IP 本身有并发数限制，所以当资源一多，速度就显著慢下来。
  * HTTP 2.0中，一个 TCP/IP 请求可以请求多个资源，也就是说，只要一次 TCP/IP 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。

## HTTPS 是什么？

* HTTPS 就是安全版本的 HTTP，HTTP 请求的安全系数太低。
* HTTPS 在请求前，会建立 SSL 链接，确保接下来的通信都是加密的，无法被轻易截取分析
* 升级为 HTTPS
  * 一般来说，如果要将网站升级成 HTTPS ，需要后端支持(后端需要申请证书等)，然后 HTTPS 的开销也比 HTTP 要大（因为需要额外建立安全链接以及加密等），所以一般来说 HTTP 2.0 配合 HTTPS 的体验更佳(因为 HTTP2.0 更快)
* SSL/TLS的握手流程
  * 浏览器请求建立 SSL 链接，并向服务端发送一个随机数，Client random 和客户端支持的加密方法，比如 RSA 加密，此时是明文传输。
  * 服务端从中选出一组加密算法与 Hash 算法，回复一个随机数，Server random，并将自己的身份信息以证书的形式发回给浏览器(证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息)
  * 浏览器收到服务端的证书后
    * 验证证书的合法性(颁发机构是否合法，证书中包含的网址是否和正在访问的一样)，如果证书信任，则浏览器会显示一个小锁头，否则会有提示。
    * 用户接收证书后(不管信不信任)，浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密 Premaster secret，发送给服务器。
    * 利用 Client random、Server random和 Premaster secret 通过一定的算法生成 HTTP 链接数据传输的对称加密 key- session key
    * 使用约定好的 HASH 算法计算握手消息，并使用生成的 session key 对消息进行加密，最后将之前生成的所有信息发送给服务端。
  * 服务端收到浏览器的回复
    * 利用已知的加解密方式与自己的私钥进行解密，获取 Premaster secret
    * 和浏览器相同规则生成 session key
    * 使用 session key 解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致
    * 使用 session key 加密一段握手消息，发送给浏览器
  * 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。

## HTTP 的主要方法？

PUT 和 DELETE 常用于 RESTful API 设计中，App 和后端交互时常用

* GET，获取 URI 指定的信息(文件、CGI 程序)。
* POST，发送数据。
* HEAD，只返回 HTTP 消息头。
* OPTIONS，用于通知或查询通信选项。
* PUT，替换 URI 指定的服务器上文件，若不存在则新建。
* DELETE，删除  URI 指定的服务器上文件，若不存在则新建。
* TRACE，将服务器收到的请求行和头部直接返回。
* CONNECT，代理传输加密消息时使用的方法。

## HTTP 报文结构与常见字段？

```markdown
# 请求报文
# 消息头，从 字段名:字段值 开始，一直延伸到空行。
# 消息体可以包含 POST 方法要发送的内容等。
方法<空格>URI<空格>HTTP 版本
字段名:字段值
...
空行
消息体
# 响应报文
# 消息体均为二进制：文件中读取的数据、如 CGI 程序输出的数据
HTTP 版本<空格>状态码<空格>响应短语
字段名:字段值
...
空行
消息体
```

## 常见的 HTTP 状态码都有哪些？

* 1XX 消息，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。
* 2XX 成功，代表请求已成功被服务器接收、理解、并接受。
* 3XX 重定向，代表需要客户端采取进一步的操作才能完成请求。通常用来重定向，后续的请求地址(重定向目标)在本次相应的 Location 域中指明。当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向(例如：A→B→C→……→A 或 A→A)，因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。
* 4XX 客户端错误，代表客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。
* 5XX 服务器错误，代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。

| 状态码 | 状态码英文名称      | 中文描述                                                     |
| ------ | ------------------- | ------------------------------------------------------------ |
| 100    | Continue            | 继续。客户端应继续其请求.                                    |
| 101    | Switching Protocols | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。 |
| 102    | Processing          | 表示服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。 |

| 状态码 | 状态码英文名称                | 中文描述                                                     |
| ------ | ----------------------------- | ------------------------------------------------------------ |
| 200    | OK                            | 请求成功，请求所希望的响应头或数据体将随此响应返回。一般用于 GET 与 POST 请求。 |
| 201    | Created                       | 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其 URI 已经随 Location  头信息返回。假如需要的资源无法及时创建的话，应当返回 '202 Accepted'。 |
| 202    | Accepted                      | 服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。 |
| 203    | Non-Authoritative Information | 非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而返回转换代理服务器上的一个副本 |
| 204    | No Content                    | 服务器成功处理了请求，没有返回任何内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                 | 服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。可通过此返回码清除浏览器的表单域。 |
| 206    | Partial Content               | 服务器已经成功处理了部分 GET 请求。HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 |
| 207    | Multi-Status                  | 代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 |
| 208    | Already Reported              | DAV 绑定的成员已经在(多状态)响应之前的部分被列举，且未被再次包含。 |
| 226    | IM Used                       | 服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。 |

| 状态码 | 状态码英文名称     | 中文描述                                                     |
| ------ | ------------------ | ------------------------------------------------------------ |
| 300    | Multiple Choices   | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端(例如：浏览器)选择 |
| 301    | Moved Permanently  | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替 |
| 302    | Found              | 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI |
| 303    | See Other          | 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看         |
| 304    | Not Modified       | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy          | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused             | 已经被废弃的 HTTP 状态码                                     |
| 307    | Temporary Redirect | 临时重定向。与 302 类似。使用 GET 请求重定向                 |
| 308    | Permanent Redirect | 状态码                                                       |

| 400  | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| ---- | ------------------------------- | ------------------------------------------------------------ |
| 401  | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402  | Payment Required                | 保留，将来使用                                               |
| 403  | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | Not Found                       | 服务器无法根据客户端的请求找到资源(网页)。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405  | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406  | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407  | Proxy Authentication Required   | 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权 |
| 408  | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409  | Conflict                        | 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410  | Gone                            | 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置 |
| 411  | Length Required                 | 服务器无法处理客户端发送的不带 Content-Length 的请求信息     |
| 412  | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413  | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息 |
| 414  | Request-URI Too Large           | 请求的 URI 过长(URI通常为网址)，服务器无法处理               |
| 415  | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416  | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417  | Expectation Failed              | 服务器无法满足 Expect 的请求头信息                           |

| 500  | Internal Server Error      | 服务器内部错误，无法完成请求                                 |
| ---- | -------------------------- | ------------------------------------------------------------ |
| 501  | Not Implemented            | 服务器不支持请求的功能，无法完成请求                         |
| 502  | Bad Gateway                | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |
| 503  | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 |
| 504  | Gateway Time-out           | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505  | HTTP Version not supported | 服务器不支持请求的 HTTP 协议的版本，无法完成处理             |

## HTTP 的缓存机制是怎样的？

* 缓存可以简单的划分成两种类型：强缓存(200 from cache)与协商缓存(304)。
  * 强缓存(200 from cache)时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 HTTP 请求。对于强缓存，在未过期时，必须更新资源路径才能发起新的请求。
  * 协商缓存(304)时，浏览器会向服务端发起 HTTP 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存。对于协商缓存，使用 Ctrl + F5 强制刷新可以使得缓存无效。
* HTTP 缓存头部
  * 强缓存和协商缓存通过缓存头部区分。常用的缓存头部有：If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires。
  * 属于强缓存控制的：
    * (http1.1)Cache-Control/Max-Age，Max-Age 不是一个头部，它是 Cache-Control 头部的值
    * (http1.0)Pragma/Expires
  * 属于协商缓存控制的：
    * (http1.1)If-None-Match/E-tag
    * (http1.0)If-Modified-Since/Last-Modified
* 其实 HTML 页面中也有一个 meta 标签可以控制缓存方案 Pragma，不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐。`<META HTTP-EQUIV="Pragma" CONTENT="no-cache">`

Max-Age 与 Expires

- Expires 使用的是服务器端的时间
- 但是有时候会有这样一种情况-客户端时间和服务端不同步
- 那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期
- 所以一般 HTTP 1.1 后不推荐使用 Expires
- 而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题
- 因此推荐使用Max-Age
- 注意，如果同时启用了 Cache-Control 与 Expires，Cache-Control 优先级高

E-tag 与 Last-Modified

* Last-Modified：
  * 表明服务端的文件最后何时改变的
  * 它有一个缺陷就是只能精确到 1s，
  * 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效
* E-tag：
  * 是一种指纹机制，代表文件相关指纹
  * 只有文件变才会变，也只要文件变就会变，
  * 也没有精确时间的限制，只要文件一遍，立马 E-tag 就不一样了

HTTP 各版本缓存控制头部

* HTTP 1.0 中的缓存控制头部：
  - **Pragma**：严格来说，它不属于专门的缓存控制头部，但是它设置 no-cache 时可以让本地强缓存失效(属于编译控制，来实现特定的指令，主要是因为兼容 HTTP1.0，所以以前又被大量应用)
  - **Expires**：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如 Expires：Fri, 30 Oct 1998 14:19:41
  - **If-Modified-Since/Last-Modified**：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-Modified-Since，而服务端的是 Last-Modified，它的作用是，在发起请求时，如果 If-Modified-Since 和 Last-Modified 匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到 1s 以内
* HTTP 1.1 中的缓存控制头部：
  - **Cache-Control**：缓存控制头部，有 no-cache、max-age 等多种取值
  - **Max-Age**：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算
  - **If-None-Match/E-tag**：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-None-Match，而服务端的是 E-tag，同样，发出请求后，如果 If-None-Match 和 E-tag 匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，它是类似于指纹一样的东西，基于 FileEtag INode Mtime Size 生成，也就是说，只要文件变，指纹就会变，而且没有 1s 精确度的限制。

## 如何理解 CDN？

> [也许是史上最全的一次 CDN 详解](https://zhuanlan.zhihu.com/p/28940451)

* CDN 内容分布网络是构筑在现有的 Internet 上的一种先进的流量分配网络，是一层新的网络架构
  * CDN 系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
  * 控制时延：现代信息科技的重要指标，CDN 的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。
* CDN 的意义：

  * 为了实现跨运营商、跨地域的全网覆盖：互联不互通、区域 ISP 地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN 加速可以覆盖全球的线路，通过和运营商合作，部署 IDC 资源，在全国骨干节点商，合理部署 CDN 边缘分发存储节点，充分利用带宽资源，平衡源站流量。
  * 为了保障你的网站安全：CDN 的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。
  * 为了异地备援：当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近 100% 的可靠性，这就让你的网站可以做到永不宕机。
  * 为了节约成本投入：使用 CDN 加速可以实现网站的全国铺设，不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。
  * 为了更专注业务本身：CDN 加速厂商一般都会提供一站式服务，业务不仅限于 CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供 7x24 运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。
* 最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成。
* 一个 CND 架构 = 镜像（Mirror）+ 缓存（Cache）+整体负载均衡（GSLB）

## TCP/IP 的三次握手与四次挥手？

> * [TCP 的那些事儿](https://coolshell.cn/articles/11564.html)
> * [“三次握手，四次挥手”你真的懂吗？](https://zhuanlan.zhihu.com/p/53374516)
> * 35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题, https://www.cnblogs.com/xiaolincoding/p/12638546.html
> * https://hit-alibaba.github.io/interview/basic/network/TCP.html
> * https://juejin.im/post/6844904070000410631
> * https://juejin.im/post/6844903958624878606

* 大白话
  * 三次握手
    - client：hello，你是 server 么？
    - server：hello，我是 server，你是 client 么？
    - client：yes，我是 client
  * 四次挥手
    - 主动方：我已经关闭向你那边的主动通道了，只能被动接受了
    - 被动方：收到通道关闭消息
    - 被动方：那我也告诉你，我这边向你的主动通道也关闭了
    - 主动方：最后收到数据，之后双方无法通信

## TCP/IP 的长连接和短连接什么区别？

> Keep-Alive 不会永远保持，它有一个持续时间，一般在服务器中配置(如 Apache)，另外长连接需要客户端和服务器都支持时才有效

* TCP/IP 层面的定义：
  - 长连接：一个 TCP/IP 连接上可以连续发送多个数据包，在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持(类似于心跳包)
  - 短连接：通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接
* HTTP 层面的定义：
  - HTTP 1.0 中，默认使用的是短连接，也就是说，浏览器没进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接。
  - HTTP 1.1 起，默认使用长连接，使用长连接会有这一行 `Connection: keep-alive`，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 HTTP 的 TCP 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接。

## 如何理解 IPv4？

> [IP 基础知识全家桶，45 张图一套带走](https://zhuanlan.zhihu.com/p/138235610)

* IP 在 TCP/IP 参考模型中处于第三层，也就是网络层（实现主机与主机之间的通信，也叫点对点通信）。
  * IP 负责将数据包发送给最终的目的地址；MAC 只负责某一个区间之间的通信传输。
  * 源 IP 地址和目标 IP 地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。
* IPv4：32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。
  * IPv4 地址长度共 32 位，是以每 8 位作为一组，并用点分十进制的表示方式。
  * 最大容量：2^32 约 43 亿台计算机。一个设备可以有多个 IP，IP 不可能被 100% 填满。
    * A 类：首部 0，网络号 7 位，主机号 24 位
      * `0.0.0.0~127.255.255.255`，最大主机数 16777214
      * 私有 IP 地址范围：`10.0.0.0~10.255.255.255`
      * 环回地址：`127.0.0.1`
    * B 类：首部 10，网络号 14 位，主机号 16 位
      * `128.0.0.0~191.255.255.255`，最大主机数 65534
      * 私有 IP 地址范围：`172.16.0.0~172.31.255.255`
    * C 类：首部 110，网络号 21 位，主机号 8 位
      * `192.0.0.0~223.255.255`，最大主机数 254
      * 私有 IP 地址范围：`192.168.0.0~192.168.255.255`。
    * D 类：首部 1110，组播地址 28 位
      * 常被用来 IP 多播
    * E 类：首部 1111，留待后用 28 位
  * 广播：
    * 主机号全为 1 指定某个网络下的所有主机，用于广播；主机号全为 0 指定某个网络。
    * 广播地址 - 本地广播
    * 广播地址 - 直接广播。
  * 多播：用于将包发送给特定组内的所有主机。
    * 使用的 D 类地址，其前四位是 1110 就表示是多播地址，而剩下的 28 位是多播的组编号。
    * 从 `224.0.0.0 ~ 239.255.255.255` 都是多播的可用范围，其划分为以下三类：
      * `224.0.0.0 ~ 224.0.0.255` 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。
      * `224.0.1.0 ~ 238.255.255.255` 为用户可用的组播地址，可以用于 Internet 上。
      * `239.0.0.0 ~ 239.255.255.255` 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。
  * 组播。
  * IPV4 的缺点：同一网络下没有地址层次。C 类地址太少，B 类地址对一般企业太多。
  * 私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 `ICANN` 组织管理，中文叫「互联网名称与数字地址分配机构」。

## 如何理解 IPv4 的 CIDR/NAT/ICMP/IGMP？

* CIDR：无分类地址的方案
  * 表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。

* NAT 技术：可更换 IP 地址
  * 缺点：
    * 外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。
    * 转换表的生成与转换操作都会产生性能开销。
    * 通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。
  * 解决缺点 - Nat 穿透技术：让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。

## 如何理解 IPv4 的子网掩码/分片重组/DHCP？

* 子网掩码：
  * 掩码的意思就是掩盖掉主机号，剩余的就是网络号。
  * 将子网掩码和 IP 地址按位计算 AND，就可得到网络号。`10.100.122.2 & 255.255.255.0 === 10.100.122.0`
  * 子网掩码还有一个作用，那就是划分子网。
  * 子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。
    * 未做子网划分的 IP 地址：网络地址＋主机地址
    * 做子网划分后的 IP 地址：网络地址＋（子网网络地址＋子网主机地址）

* IP 分片与重组：
  * 当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。IP 数据报只能由目标主机重组。
  * 每种使用目的不同的数据链路的最大传输单元 `MTU` 都是不相同的，如 FDDI 数据链路 MTU 4352、最常见的以太网的 MTU 是 1500 字节等。
  * 在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP 引入了 `MSS` 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 `MTU` 的数据报文。
* DHCP：通过 DHCP 服务器动态获取 IP 地址
  * 流程
    * 客户端首先发起 **DHCP 发现报文（DHCP DISCOVER）** 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP **广播**通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。
    * DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文（DHCP OFFER）** 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 **IP 地址租用期**。
    * 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 **DHCP 请求报文（DHCP REQUEST**进行响应，回显配置的参数。
    * 最后，服务端用 **DHCP ACK 报文**对 DHCP 请求报文进行响应，应答所要求的参数。
  * 一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。
  * 如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：
    * 服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。
    * 服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。
  * 由于全程都是使用 UDP 广播通信，所以有了 **DHCP 中继代理**。有了 DHCP 中继代理以后，**对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。**
    * DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以**单播**的形式发给 DHCP 服务器。
    * 服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端。
  * 因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。

## 如何理解 IPv6？

* 特点：
  * 数量惊人的可分配地址
  * 更好的安全性和扩展性
  * 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址
  * 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大提高了传输的性能。
  * IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性。
* IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。
* 如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。
* 类型地址：
  * 单播地址，用于一对一的通信。
    * 在同一链路单播通信，不经过路由器，可以使用**链路本地单播地址**，IPv4 没有此类型
    * 在内网里单播通信，可以使用**唯一本地地址**，相当于 IPv4 的私有 IP
    * 在互联网通信，可以使用**全局单播地址**，相当于 IPv4 的公有 IP
  * 组播地址，用于一对多的通信
  * 任播地址，用于通信最近的节点，最近的节点是由路由协议决定
  * 没有广播地址
* 未定义：`::/128`；环回地址：`::1/128`；唯一本地地址：`FC00::/7`；链路本地单播地址：`FE80::/10`；多播地址：`FF00::/8`。
* IPv6 相比 IPv4 的首部改进：
  - **取消了首部校验和字段。** 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
  - **取消了分片/重新组装相关字段。** 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
  - **取消选项字段。** 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 `40` 字节。

## DNS 域名解析机制

1. 客户端首先会发出一个 DNS 请求，问 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com)，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“[http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 的 IP 地址吗？”
5. 顶级域名服务器说：“我给你负责 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，[http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com)对应的IP是啥呀？” [http://server.com](https://link.zhihu.com/?target=http%3A//server.com) 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

## 如何理解 ARP 协议和 MAC 地址？

* ARP 是借助 **ARP 请求与 ARP 响应**两种类型的包确定 MAC 地址的。
  * 主机会通过**广播发送 ARP 请求**，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。
  * 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 **ARP 响应包**返回给主机。
* RARP 协议已知 MAC 地址求 IP 地址

## DNS 服务器的工作机制是怎样的？

* DNS 查询得到 IP 的过程：
  * 如果浏览器有缓存、直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host
  * 如果本地没有，就向 DNS 域名服务器查询，中间过程经过的路由可能也有缓存，查询得到对应的 IP
* DNS 查询优化
  * 解析域名过多时，会让首屏加载速度变得过慢，可以考虑 dns-prefetch 优化。

```javascript
// gethostbyname 返回 IP 地址
<内存地址> = gethostbyname("要查询的服务器域名");

gethostbyname {
    生成发送给 DNS 服务器的查询信息;
    // 发送查询消息，需要委托给操作系统内部协议栈
    向 DNS 服务器发送查询消息;
    接收 DNS 服务器返回的响应消息;
    从响应消息中取出 IP 地址，存放到 <内存地址中>;
    返回应用程序;
}
```

* DNS 预解析：“Google Chrome 浏览器”等现代浏览器还采用了一种称为“DNS 预解析”的技术，可以更快地抓取和载入网页。通过 DNS 查找将网址转换为 IP 地址的过程称为“解析”，反之则称为“反向解析”。“Chrome 浏览器”会通过 DNS 预解析同时查找网页上的其他所有链接，并在后台将这些链接预解析为 IP 地址。因此，当您实际点击网页上的某个链接后，浏览器就能立即将您转到新的网页。
